ES 6 
•	Es 6 Overview
•	Babel Transpilers
•	Let ,const, block scope
•	String template literals
•	Arrow functions
•	Classes
•	inheritance
•	Instance variables, methods
•	Object Destructuring
•	Async programming and implementations
•	Call back hell
•	Promises
•	Async and await
•	ES 6 modules



NodeJS Introduction
•	Node's Architecture
•	Node's CLI and REPL
•	Global Object, Process, and Buffer
•	JSON and C++ Addons

Concurrency Model and Event Loop
•	The Event Loop
•	The Call Stack
•	Handling Slow Operations
•	How Callbacks Actually Work
•	setImmediate and process.nextTick

Node's Event-driven Architecture
•	Callbacks, Promises, and Async/Await
•	Event Emitter
•	Arguments, Errors, and Order of Listeners

NodeJS Networking
•	TCP Networking with the Net Module
•	Working with Multiple Sockets
•	The DNS Module
•	UDP Datagram Sockets

Node for Web
•	The Basic Streaming HTTP Server
•	Working with HTTPS
•	Requesting HTTP/HTTPS Data
•	Working with Routes
•	Parsing URLs and Query Strings

Node's Common Built-in Libraries
•	Working with the Operating System



    Working with the File System
    Console and Utilities
    Debugging Node.js Applications

Working with Streams
    What are Streams?
    Implementing Readable and Writable Streams
    Duplex Streams and Transform Streams

Clusters and Child Processes
    Scaling Node.js Applications
    Child Processes Events and Standard IO
    The Shell Syntax, exec(), and execFile()
    The fork() Function
    The Cluster Module
    Load-balancing an HTTP Server
    Broadcasting Messages to All Workers
    Availability and Zero-downtime Restarts
    Shared State and Sticky Load Balancing

Micro services on Node.js using Molecular

Micro Services
	What is Micro Service?
	Why Micro Services
	Distributed Application Architecture
	Domain Driven Design
	Monolithic to Micro services
	Advantages and Disadvantages


Micro Services Design Patterns
	What is Service? How to write them.
	How to Break Application , How to break down into services
	Services Using SRP Principle

	Service Communication Pattern
o	Remote Procedure Invocation
o	Messaging
o	Domain-specific protocol
	Service Discovery Patterns
o	Client-side discovery
o	Server-side discovery
o	Service registry
o	Self registration
o	3rd party registration
	Data management
o	Database per Service
o	Shared database
o	Saganew
o	API Compositionnew
o	CQRS
o	Domain event
	
	Deployment patterns
o	Multiple service instances per host
o	Service instance per host
o	Service instance per VM
o	Service instance per Container
o	Serverless deployment
o	Service deployment platform

	External API
o	API gateway
o	Backend for front-end

	Reliability
o	Circuit Breaker

	Observability
o	Log aggregation
o	Application metrics
o	Audit logging
o	Distributed tracing
o	Exception tracking
o	Health check API


What is Moleculer?
Features
	Promise-based solution (async/await compatible)
	request-reply concept
	support streams
	support event-driven architecture with balancing
	built-in service registry & dynamic service discovery
	load balanced requests & events (round-robin, random, cpu-usage, latency)
	many fault tolerance features (Circuit Breaker, Bulkhead, Retry, Timeout, Fallback)
	supports middlewares
	supports versioned services
	service mixins
	built-in caching solution (memory, Redis)
	pluggable transporters (TCP, NATS, MQTT, Redis, NATS Streaming, Kafka)
	pluggable serializers (JSON, Avro, MsgPack, Protocol Buffers, Thrift)
	pluggable validator
	multiple services on a node/server
	all nodes are equal, no master/leader node
	parameter validation with fastest-validator
	built-in health monitoring & metrics
	official API gateway module and many other modules…
.................................................................................

lab Setup:

1.node

>node --version

2.IDE  : Vs code


ES 6

ES : Ecma script 6 
 It is javascript version 6

Javascript is the powerful pl today.

 =>Object based 
 =>functional style
 =>Event driven 
PL

Object oriented vs Object based
 
oop
 ->Abstraction
 ->Encaspulation
 ->Modularity
 ->Hierachy
 ->Typing
--------------------
 ->Concurrency
 ->Persistency

Object based:
 -language does not implement all 5 principles or implement partially.
 language is called as "Object based"

functional programming and functional style programming:
........................................................

Church principles:
1. Pure function
2. function as first class citizens
3. referencial integrity
4. recurrsion and no loops


JS supports
1.function as first class citizens
2.pure function

Event driven:
............

In event driven programming, how two programms can interact each other independenly without knowing each other.

 Program1 ------talks------Program2
            why talks
   because they have to exchange data.

if you are object oriented developer
   Objects can talk each other => Object communication / Message passing

 class CartService{

  OrderService orderSerivce;

   public CartService(OrderService orderService){
	this.orderService = orderService;
   }

    public String placeOrder(){

	 return orderService.confirmOrder();
    }

 }

 class OrderService{
 
    public String confirmOrder(){
	return 'Order has been placed '
    }

 }


OrderService orderService=new OrderService();
//dependency injection
CartService cartService=new CartService(orderService);
cartService.placeOrder()

Tightly coupled approach : Objects are tightly copuled for communication

Loosly coupled object interaction pattern
 
 -Event driven programming


 class CartService{

    public String placeOrder(){

       event.subscribe('confirmOrder',data);
	
    }

 }

    subscribe : confirmOrder
 | ------------Event Channel-------------------------|
    published : confirmOrder

 class OrderService{
 
    public String confirmOrder(){
	event.emit('confirmOrder','Order has been placed ')
    }

 }

.................................................................................
JS VERSIONS
 es 1,es 3,es 4,5,6,7....

ECMA : es

JAVA SCRIPT :

1.Language fundamentals
2.Object based programming
3.functional style programming
4.ASYNC programming
5.DOM programming

ES 6
what is es 6? Why ES 6 ?
 ES 6 is js standards
ES 6 brought new and simplified syntax for javascript development.

1.Language fundamentals

 - variable declarations
  - var - es 5 
    - let and const -new keywords in es 6
.................................................................................
Running code:

>node  src/index.js


variable declarations:
.....................

var  variableName=value (literals)

var | let | const variable=literals

Types of literals:
string,number, boolean, undefined
NaN,infinity
function,object,null.

string:
/let htmlDoc = "<html>" +
      "<head>" +
      "<body>" +
      "</body>" +
      "</html>";

let title = 'IBM-Digitial';
let htmlnewDoc = `<html>
                  <head>
                        <title>${title}</title>
                  </head>
                  <body>
                        <h1>Hello</h1>
                  </body>
                  </html>
      `;
console.log(htmlDoc)
console.log(htmlnewDoc);


Numbers:
//numbers : 64 bit double

let salary = 1000;
console.log(`Salary ${salary}`);

//div / 0
let avgSalary = salary / 0;
console.log(`Avg Salary ${avgSalary}`)

//undefined is value, which is initalized if variable has no value

let qty;
console.log(qty);

let price = 100;
//NaN : Not a Number : error code
let totalPrice = price * qty;
console.log(`Total Price ${totalPrice}`);


//booelans : true /false
let isActive = true;
console.log(`isActive ${isActive}`);

//decision making
if (isActive) {
      console.log('Active')
} else {
      console.log('In Active');
}
isActive ? console.log('Active') : console.log('In Active')
//booleans
/**
 * Truthy values:
 *  In javascript everything is true execpt the following values
 * 
 * fasly values
 *  1.boolean false
 *  2.Empty string "" ,''
 *  3.0
 *  4.undefined
 *  5.NaN
 *  6.null
 */
//let firstName = 'Subramanain';
let firstName = '';
if (firstName) {
      console.log(`The first Name ${firstName}`);
} else {
      console.log('No first Name')
}

///////////////////////////////////////////////////////////////

//operators
// == , === !=,!==,!,!!

//equal operators

let x = 10;
let y = 10;
if (x == y) {
      console.log('X and Y are equal')
} else {
      console.log('X AND Y not equal')
}
// === type + content
let a = "10"; //string
let b = 10; //number
if (a === b) { // string == number
      console.log('A and B are equal')
} else {
      console.log('A AND B not equal')
}

let token = '1234';
//let isTokenAvailable = !token; //inverter
let isTokenAvailable = !!token; //inverter
console.log(`isTokenAvailable ${isTokenAvailable}`)


...................
const : read only
once variable is intialized , cant be changed.

//const

/**
 * let vs const
 *  both are same
 * let can be reinitalized 
 * const cant
 */
let a = 10;
console.log(`A ${a}`);
a = 90;
console.log(`A ${a}`);

const PI = 3.14;
console.log(`PI ${PI}`);
PI = 877;
console.log(`PI ${PI}`);

////////////////////////////////////////////////////////////////////////////////

default Function args:
function sayHello() {
      console.log('Hello!');
}
sayHello();

//function parameters and args
//default Args
function add(a = 1, b = 1) {
      return a + b;
}
console.log(add(10, 10));
console.log(add());
console.log(add(undefined, 90));


//////////////////////////////////////////////////////////////////////

Function expressions

//funciton declaration
function sayHello() {
      return 'hello';
}
//function invocation
console.log(sayHello());

//function declaration : literal pattern
//hai is just variable , which points function as value
/* let hai = function sayHai() {
      console.log('Hai');
}; */
//Anonmous function
let hai = function () {
      console.log('Hai');
};
//invoke
//sayHai();
hai();

let add = function (a=1, b=1) {
      return a + b;
};
console.log(add(10, 10));

///////////////////////////////////////////////////////////////////////////

Function expression in es 6 : Arrow functions/ Lambdas

//arrow functions

/* let hai = function () {
      console.log('Hai');
}; */
//arrow function : ES 6 version of function expression.
/**
 * Arrow function has so many flav
 */

//basic function
let hai = () => {
      console.log('Hai');
};

hai();
//with args : two parameters, with default value
let add = (a = 1, b = 1) => {
      let result = a + b;
      console.log(`The add result is ${result}`);
};
add(10, 10)
//with args : single parameter without default value : bracket() can be dropped
let welcome = name => {
      console.log(`The name is ${name}`);
};
welcome('Subramanian');

//if function body has only one line : drop {}
let welcome1 = name => console.log(`The name is ${name}`);
welcome1('Subramanian');
//return values
/* let substract = (a = 1, b = 1) => {
      return a - b;
}; */
//if function has only return statement, no more body ; you can drop {}, return statement.
let substract = (a = 1, b = 1) => a - b;
console.log(substract(10, 2));
////////////////////////////////////////////////////////////////////////////////

Function as parameter , function as return values:
..................................................

Function as parameter  : Async Programming 


//a =x
//b =y
function add(a, b) {
      console.log(a + b);
}
add(10, 10);
let x = 10;
let y = 90;
add(x, y);
//function passed as parameter to another function
//connection = dbConnection
function connect(connection) {
      //invoke function
      connection();
}
//variable anonmous function
let dbConnection = function () {
      console.log('db connection');
};
connect(dbConnection);
//inline anonmous 
connect(function () {
      console.log('NOSQL connection');
});
.............................
//function passed as parameter to another function
//connection = dbConnection
function connect(connection) {
      //invoke function
      let isConnected = connection('Connection is Up!');
      isConnected ? console.log('Connected') : console.log('Not Connected!');
      isConnected
}
//variable anonmous function
let dbConnection = function (status) {
      console.log(status);
      return true;
};
connect(dbConnection);
//inline anonmous 
connect(function (status) {
      console.log(`NoSQL ${status}`);
      return true;
});
///////////////////////////////////////////////////////////////////

Arrow version of function as parameter
let connect = connection => {
      //invoke function
      let isConnected = connection('Connection is Up!');
      isConnected ? console.log('Connected') : console.log('Not Connected!');
};
//variable anonmous function
let dbConnection = status => {
      console.log(status);
      return true;
};
connect(dbConnection);
//inline anonmous 
connect(status => {
      console.log(`NoSQL ${status}`);
      return true;
});

/////////////////////////////////////////////////////////////////

Returning function from another function.

scope : visibilty of variable,funciton

1.global scope
 node does not support global scope.
2.function scope
   any thing is declared inside function , not available
outside function.
3.block scope
  with in blocks
4.object scope
5.module scope.


called with in function.

function increment() {
      console.log('increment function is called!');
      //nested function 
      function count() {
            console.log('counter function')
      }
      //
      count();
}
increment();

function increment() {
      console.log('increment function is called!');
      //nested function 
      let count = function () {
            console.log('counter function')
      }; //
      count();
}
increment();

how to call count funciton outside increment function?


function increment() {
      console.log('increment function is called!');
      //nested function 
      /*  return function count() {
             console.log('counter function')
       } */
      /*  let count = function () {
             console.log('counter function')
       };
       return count; */
      return function () {
            console.log('counter function')
      };
}
/* let counter = increment();
counter(); */
increment()();


let decrement = () => {
      return () => console.log('Decrement');
}
decrement()();


//////////////////
block scope:

block : if,switch,loops...{}

js and blocks

js does not have block by default.


code written by you
function isValid(token) {

      if (token) {
            //block level variables
            var message = 'Token is Present'
      } else {
            //block level variables
            var errMessage = 'Token not Present';
      }

      console.log(message, errMessage);
}

result:
isValid()
  undefined,Token not Present.

|
after compilation : js alters the source code like below : hoisting: moving the code function level.

function isValid(token) {
    var message;
    var errMessage;
      if (token) {
            //block level variables
             message= 'Token is Present'
      } else {
            //block level variables
             errMessage= 'Token not Present';
      }

      console.log(message, errMessage);
}

with let keyword
source code
function isValid(token) {

      if (token) {
            //block level variables
            let message = 'Token is Present'
      } else {
            //block level variables
            let errMessage = 'Token not Present';
      }

      console.log(message, errMessage);
}
compiled code

function isValid(token) {

      if (token) {
            //block level variables
            let message = 'Token is Present'
      } else {
            //block level variables
            let errMessage = 'Token not Present';
      }

      console.log(message, errMessage);
}
////////////////////////////////////////////////////////////////////////////////

Object based programming:

Object : Memory layout containing data  and how data to be manpulated.

In js every thing is object expect some few values: undefined.

How to create Object?

1.COnstructors
  1.1.using traditional function
  1.2.using es 6 classes
2.Literals


//function as Object template

/* function Employee() {
      //data + methods
      this.id = 1;
      this.firstName = 'Divya Sree';
      this.lastName = 'Subramanian';
      //methods
      this.calculateSalary = function () {
            return 100 * 100;
      }
} */
//class
class Employee {
      id = 1;
      firstName = 'Divya Sree';
      lastName = 'Subramanian';
      //methods
      /* calculateSalary = function () {
            return 100 * 100;
      } */
      /*  calculateSalary() {
             return 100 * 100;
       } */
      calculateSalary = () => {
            return 100 * 100;
      }
}
//Object creation
let emp = new Employee();
console.log(`Id ${emp.id} name ${emp.firstName} ${emp.lastName} ${emp.calculateSalary()}`)


State initalization: data

1.hardcoded directly inside class

class Employee {
      //instance variables
      id = 1;
      firstName = 'Divya Sree';
      lastName = 'Subramanian';
      //methods
      /* calculateSalary = function () {
            return 100 * 100;
      } */
      /*  calculateSalary() {
             return 100 * 100;
       } */
      calculateSalary = () => {
            return 100 * 100;
      }
}

2.after object creation 

//function as Object template

/* function Employee() {
      //data + methods
      this.id = 1;
      this.firstName = 'Divya Sree';
      this.lastName = 'Subramanian';
      //methods
      this.calculateSalary = function () {
            return 100 * 100;
      }
}
*/
class Employee {
      //instance variables
      id = 1;
      firstName = 'Divya Sree';
      lastName = 'Subramanian';
      calculateSalary = () => {
            return 100 * 100;
      }
}

//Object creation
let emp = new Employee();

console.log(`Id ${emp.id} name ${emp.firstName} ${emp.lastName} ${emp.calculateSalary()}`)
//state initalization
emp.id = 1000;
emp.firstName = 'Subramanian';
emp.lastName = 'Murugan';
console.log(`Id ${emp.id} name ${emp.firstName} ${emp.lastName} ${emp.calculateSalary()}`)


3.through constructors parameters


/* function Employee(id = 1, firstName = 'Divya Sree', lastName = 'Subramanian') {
      //data + methods
      this.id = id;
      this.firstName = firstName;
      this.lastName = lastName;
      //methods
      this.calculateSalary = function () {
            return 100 * 100;
      }
} */
class Employee {
      //instance variables     
      constructor(id = 1, firstName = 'Divya Sree', lastName = 'Subramanian') {
            this.id = id;
            this.firstName = firstName;
            this.lastName = lastName;
      }
      calculateSalary = () => {
            return 100 * 100;
      }
}
//let emp = new Employee(1, 'Subramanian', 'Murugan');
let emp = new Employee();
console.log(`Id ${emp.id} name ${emp.firstName} ${emp.lastName} ${emp.calculateSalary()}`)



Literal object:
//literal pattern

let emp = {
      id: 1,
      firstName: 'DivaSree',
      lastName: 'Subramaian',
      /*  calculateSalary: function () {
             return 1000;
       } */
      /*  calculateSalary: () => {
             return 1000;
       } */
      calculateSalary() {
            return 1000;
      }
};
console.log(`Id ${emp.id} name ${emp.firstName} ${emp.lastName} ${emp.calculateSalary()}`)

emp.id = 100;
emp.firstName = 'foo';
emp.lastName = 'bar';
console.log(`Id ${emp.id} name ${emp.firstName} ${emp.lastName} ${emp.calculateSalary()}`)
////////////////////////////////////////////////////////////////////////////////

Object Relationship: IS-A, HAS-A

IS-A : Inheritance : Prototype based


//class based inheritance

class Account {
      constructor() {
            console.log('Account class Constructor');
      }
}
class SavingsAccount extends Account {
      constructor() {
            super()
            console.log('Savings Account class Constructor');
      }
}

let sb = new SavingsAccount();


//class based inheritance

class Account {
      constructor(id = 1, name = 'foo') {
            console.log('Account class Constructor');
            this.id = id;
            this.name = name;
      }
      //methods
      withdraw() {
            return 100;
      }
}
class SavingsAccount extends Account {
      constructor(id, name) {
            super(id, name)
            console.log('Savings Account class Constructor');
      }
      //overriding: redefining
      withdraw() {
            return 500 * super.withdraw();
      }
}

let sb = new SavingsAccount(12, 'subramanian');
console.log(`id ${sb.id} name ${sb.name} amount ${sb.withdraw()}`)

sb.id = 900;
sb.name = 'bar'
console.log(`id ${sb.id} name ${sb.name}`)


Has-a:
//Controller
class OrderController {
      constructor(orderService = new OrderService()) {
            this.orderService = orderService;
      }
      //biz methods
      findAll() {
            return this.orderService.findAll();
      }
}

//Service
class OrderService {
      constructor(repository = new OrderRepository()) {
            //has -a: dependency injection
            this.repository = repository;
      }
      findAll() {
            return this.repository.findAll();
      }
}

//Repository
class OrderRepository {
      constructor() {

      }
      findAll() {
            return [{
                        id: 1,
                        totalValue: 210232,
                        product: 'Lenvo think PAD'
                  },
                  {
                        id: 2,
                        totalValue: 310232,
                        product: 'Mac Book Pro'
                  }
            ];
      }
}
//Main App
/* let repository = new OrderRepository();
let orderService = new OrderService(repository);
let orderController = new OrderController(orderService); */
let orderController = new OrderController(new OrderService(new OrderRepository()));
//invoke biz mehtods
orderController.findAll().forEach(order => {
      console.log(`${order.id} ${order.totalValue} ${order.product}`)
});

///////////////////////////////////////////////////////////////////////////////
Object Destrucing:

//Object destrucing
/* 
function displayEmployee(employee) {
      //display employee details
      console.log(`id ${employee.id} name ${employee.name} ${employee.salary}`)
} */
//short cut to access object property : destrucing

/* function displayEmployee(employee) {
      //
      const { id, name, salary } = employee;
      //display employee details
      console.log(`id ${id} name ${name} ${salary}`)
} */

/* function displayEmployee({
      id,
      name,
      salary
}) {
      //display employee details
      console.log(`id ${id} name ${name} ${salary}`)
} */

const displayEmployee = ({
      id,
      name,
      salary
}) => console.log(`id ${id} name ${name} ${salary}`)

displayEmployee({
      id: 1,
      name: 'subramanian',
      salary: 4000
});

const displayEmployee = ({
      id,
      name,
      salary,
      address: {
            city
      }
}) => console.log(`id ${id} name ${name} ${salary} ${city}`)
displayEmployee({
      id: 1,
      name: 'subramanian',
      salary: 4000,
      address: {
            city: 'Coimbatore'
      }
});
..................................................................................

Parameters:

function getProduct(id, name) {
      return {
            id: id,
            name: name
      }
}
let products = getProduct(1, 'Lenvo think Pad');
console.log(products)


function getProduct(id, name) {

      /* return {
            //objectkey:localvariable ==same =>make it one
            id: id,
            name: name
      } */
      return {
            id,
            name
      }
}
let products = getProduct(1, 'Lenvo think Pad');
console.log(products)

*****************....................********************************************
Node:
.....
What is Node?
Why Node is?
How Node works?

 "Node is non blocking IO Platform for building IO application on javascript"

Javascript cant be used for building IO Application.
Javascript invented for web document manipulation.

What is IO APPLICATIONS?
I -iNPUT -Read
O -OUPT - Write

io = read + write.

Every pl supports IO.


IN node IO is non blocking.

What is non blocking?


Concurrency:
 Doing multiple things at the same time.

How to implement concurrency?
 
Process ==> Multi Process 
SubProcess => Multi subprocess

Process : program in execution.

Types of Program:
1.Passive Program
  Program which is in harddisk
2.Active Program
  Program which is in RAM. => Process.

Computers support multi process with help of time sharing concepts

Any thing inside RAM: Will have structure

Process has structure

what javascript code is executed?
  ->inside javascript engine.
javascript engine is process : V8,Spider Monkey,Chakra
 JVM is also process

Heap :
  Allocating memory during runtime.
  Allocating memory for Running code dynamically.
  in js /jvm : object creations

Stack :
 For creating stack frames-threads

Program Data :


function  add(a,b){
  return a+b;
}

add(10,10); => function invocation===>allocate memory==>?Stack


...............................................................................

Multi threading:

javascript does not support multi threading. Js has only one thread. Programmer cant create multi threads.

function  add(a,b){
  return a+b;
}

add(10,10);===>stack==>stackframe(a thread)===>running==complete

add(10,10);===>stack==>stackframe(a thread)===>running==complete

add(10,10);===>stack==>stackframe(a thread)===>running==complete

Sequenctial flow:  sync work flow

Can i have multi threading(concurrency) in javascript?

Yes!.....Concurrency implementation in javascript is so different than other languages.

Concurrency model is called as "Event Loop concurrency" based on design pattern called "Reactor design pattern"

Why Reactor design pattern based concurrency?
 Because of evils of threads.

1.Resource 
2.Thread dead lock
3.Race conditions


Use case :

if a thread is created to read big files like 10 GB file.
 if you create more and more threads for such heavy file io operations.


"Blocking IO" : a thread may block a resource on process during file read operation.

"NonBlocking" / Async Concurrency /Reactor Design pattern model.



Event Queue:
  The place where all completed task is saveed in the form of message called
Event Message.

What could be inside that message?
 Message  = {data + how to handle message message: handler =>function=>callback function)

Event loop:
 It is while loop, which iterates Event Queue


How to delegate to os? What is condition ? How js engine will come to know to delegate to back ground?

 add------->stack---frame created--execution-complete

 addAsync---->stack--framecreate--|is this api is part of browser api or not--if it is then that api is exectued in the back ground.


Javascript language provides built in async api's:
..................................................
1.Timers
   setTimeout,setInterval
2.XMLHttpRequest (Ajax)
3.WebSocket
4.DOM Event apis -click,mousemove....


Node Architecture:

Node was built for building heavy IO APPLICATIONS in blocking / async way 


Types of IO
1.FS IO
2.Network IO
   -Socket Programming
       ->HTTP,TCP/IP,UDP

Web Applications using java:
 JEE ,Servlets/jsp=>Tomcat ,JBoss=>containers=>JVM

 When you give request---------------->Tomcat---create a thread--thread run


Node Building blocks

Node was built on the top javascript engine from google called "V8"

V8
Libuv
  ->non block io apis
  ->Event Queue
  ->Event loops
  ->Thread Pools
Node bindings api
..................................................................................

Node in web applicaiton

User ----request-------------Node Runtime-----delegate to os kernal

..................................................................................

Node Programming:

1.how to run js on node.
2.Global Objects in node
3.Node js and javascript modularity.
4.Node and event driven programming
5.Node io programming
   ->FS
   -Web programming



1.how to run js on node.

 ->MODE
   -REPL : Read  Evulate Print Loop : interactive cmd line mode.
   -node command

eg:
node src/inputjsfile.js

java com.ibm.Main

node does not support browser objects
 ->document,window,history....

in browser window is parent  object

in node process is parent object

Process is core object:
 which contains information about The Node runtime.

Node supports 
 ->Date,Math,Number,String,Boolean,JSON.....


..................................................................................
Javascript and modularity:

How to write many programs,share code across the files.

Modularity in java : through packages.

JS has only file modularity.=> .js files


In 2000, JS communities brought design patterns that how to link files and how to share code?

1.Namespace design pattern
2.AMD : Async module design pattern
3.CJS : Common js : 2006 

Note : Node was born in 2007-2008, when node was created , Node creator integrated
CJS in the Node platform.


4.2012 ES 6 committe brought new design pattern 
  -ES 6 module design pattern

5.System

6.UMD


CJS : Common js 

 Sharing code among files : Module scope.
 Linking files with other files

Code :
 -variable declarations
 -classes declarations
 -function declarations

name.js
let name='subramanian'

greeter.js

console.log(`welcome to ${name}`);

CJS Provides keywords to share the code.

code sharing
exports
module.exports

linking
require()



exports is just variable, its intial is empty literal object

 let exports= {};
 
 exports.name = 'Subramanian';

 let exports= {name:'Subramanian'};
 
 return exports


 require('./name');

eg:
name.js
exports.name = 'Subramanian';
exports.city = 'Coimbatore'
exports.status = true



/*
 This is behind the scene node will take care

function returnModule(){
let exports= {};

//let exports= {name:'Subramanian',city:'Coimbatore',status:true};
exports.name = 'Subramanian';
exports.name = 'Subramanian';
exports.city = 'Coimbatore'
exports.status = true
return exports
}
 */



index.js

//{name:'Subramanian',city:'Coimbatore',status:true};
/* const info = require('./name');

console.log(`Name ${info.name}`);
console.log(`City ${info.city}`);
console.log(`Status ${info.status}`); */
//object desturcing
const {
      name,
      city,
      status
} = require('./name');

console.log(`Name ${name}`);
console.log(`City ${city}`);
console.log(`Status ${status}`);
................................................................................

src/config/appconfig.js

exports.version = '1.0.0'
exports.appname = 'IBM Digital'
exports.author = 'IBM';
//method exports
exports.getToken = function () {
      return `Key: ${Math.random()}`
}

src/index.js

const {
      appname,
      version,
      author,
      getToken
} = require('./config/appconfig');

console.log(appname, version, author, getToken());
.................................................................................

module.exports and exports are same : sharing code

1.exports can exports anything after packing inside a single object
   exports= {name:'Subramanian',city:'Coimbatore',status:true};

2.exports can export multiple things at the same.

1.module.exports does not export via object rather than it exports "As it is".

   const name='test'
   module.exports= name ======> name

2.module.exports cant export multiple things at the same time.
   only one single export.

 use case : single file , single class.


const ORDERS = [{
            id: 1,
            totalValue: 210232,
            product: 'Lenvo think PAD'
      },
      {
            id: 2,
            totalValue: 310232,
            product: 'Mac Book Pro'
      }
];
class OrderRepository {
      constructor() {
            console.log('Order Repository is being initalized');
      }
      findAll() {
            return ORDERS;
      }
}

module.exports = OrderRepository;


const OrderRepository = require('./OrderRepository');

class OrderService {
      constructor(orderRepo = new OrderRepository()) {
            this.orderRepo = orderRepo;
      }
      findAll() {
            return this.orderRepo.findAll();
      }
}

module.exports = OrderService;


const OrderService = require('./OrderService');

class OrderController {
      constructor(orderService = new orderService()) {
            this.orderService = orderService;
      }
      findAll() {
            return this.orderService.findAll();
      }
}
module.exports = OrderController

const OrderRepository = require('./OrderRepository');
const OrderService = require('./OrderService');
const OrderController = require('./OrderController');


function init() {
      let controller = new OrderController(new OrderService(new OrderRepository()));
      controller.findAll().forEach(order => console.log(`${order.id} ${order.totalValue} ${order.product}`));
}
init();
..................................................................................
node modules:

Types of node modules:

1.Custom module
  Written you , eg: OrderController....
2.in built modules
   Modules are supplied by node , which are supplied during node installation.

In built Modules:

1.OS
 Operating system information



 require('./OrderRepository');
  ->here you can see ./
  ./ -current dir
 require('os'); => 
  -here no ./ 

 Why?

Note : if you are java devp, you know the classpath , how it works?

 require('os');

Node internally uses a search algorthim,node always looks the folder called
 "node_modules" in the current project, if not , then it searches, the node in built installtion folder---c:/pf/node/node_nodules--if it finds it will pick up from there else it will throw error.


require('./OrderRepository'); 
   it will lookup in the current dir or sub dirs only.


//os module
//os.js
const os = require('os');

console.log(os.platform())

console.log(os.arch())
console.log(os.cpus())

.................................................................................

EventEmitter: How to write event driven programming.

 It is used to build driven programming.
 In node js most io applications are event driven.


//Event Emitter
//events.js
const EventEmitter = require('events');

//Create EventEmitter Object
const emitter = new EventEmitter();

//Subscriber : Who listens for signal(event) and data
emitter.on('greet', function (data) {
      console.log('data', data);
});
//Publisher: Publisher will send a signal(event) and data

//greet is event, Hello is data
emitter.emit('greet', 'Hello');

const EventEmitter = require('events');


//domain class with event emitters

class OrderService extends EventEmitter {
      constructor() {
            super();
            this.on('order', function (order) {
                  console.log('Order has been processed!')
                  console.log(order);
            });
      }
      //biz method
      placeOrder(order) {
            this.emit('order', order);
      }
}
let orderService = new OrderService();
orderService.placeOrder({
      id: 1,
      totalValue: 10000,
      name: 'Lenvo Think Pad Gen 2'
})

//////////////////////////////////////////////////////////////////////////////////

How to write async or non blocking programming?


Requirements to write async code?

1.You must have low level async api and eq high level async api
2.handler function / callback function : function as param.

api for async code: in node

1.timers
2.non blocking io apis
  -fs,http,ftp.....


//Async code with timers

function sayHello() {
      return 'Hello'
}

function sayGoodBye() {
      return 'Good Bye!';
}

function start(handler) {
      //invoke hanlder
      setTimeout(function () {
            handler();
      }, 5000);
}
let sleep = function () {
      console.log('I have slept well!');
};
console.log(sayHello());
start(sleep);
console.log(sayGoodBye());

//////////////////////////////////////////////////////////////////////////////////

Style of writing async code

1.callback pattern  : which is core
2.Promise Pattern
3.async and await pattern


callback Pattern:
1.passing function as a parameter which is called
  because of async operations.

start(function () {
      console.log('I have slept well again!');
});

Any problems with callback pattern?
 -Callback hell


Work flow
getUser--->getLogin--->dashboard
	|          |    
       stop       stop


//Callback Hell : when you nest so many async calls, it will lead complexity with respect to code maintaince,debugging,lot of boiler plate code



//return data if available else return error message
const getUser = (success, failure) => {
      let fakeUser = {
            name: 'Subramanian'
      };
      // let fakeUser;
      //biz logic
      if (fakeUser) {
            setTimeout(() => success(fakeUser), 1000);
      } else {
            setTimeout(() => failure({
                  err: 'User data not Found!'
            }), 1000);
      }
};
const login = (user, success, failure) => {
      if (user.name === 'Subramanian') {
            setTimeout(() => success({
                  loginsuccess: 'valid User',
                  userName: user.name
            }), 1000);
      } else {
            setTimeout(() => failure({
                  err: 'Invaild User'
            }), 1000);
      }
}
const dashboard = user => {
      console.log(`Welcome to ${user}`);
}

//function as param
getUser(user => {
      login(user, isValidUser => {
            dashboard(isValidUser.userName)
      }, err => console.log(err))
}, err => {
      console.log(err)
});

//////////////////////////////////////////////////////////////////////////////////

How to write better async programming ?

 Callback is complex.

Design pattern:
1.Promise is design pattern which hides complexity of callback patterns


SInce Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks

2012 E6 Commit introduced Promise as Object in javascript



Features of Promise Object:

1.Promise by deafult is Async. Which implements timer api with 0 ms .

Promise can be used with any async implementations.

Promise Implemenation:

1. Create Promise Object from Promise contructor
2. Create PRomise object from factory apis 

Promise object methods:
1.then
2.catch
3.finally
4.resolve
5.reject
6.all

//Promise Factory api : Success

function getPromise() {
      return Promise.resolve('done');
}
console.log('start')
getPromise().then(res => console.log(res));
console.log('end');


//

const getUser = () => {
      /*   let fakeUser = {
              name: 'Subramanian'
        }; */
      let fakeUser;
      if (fakeUser) {
            return Promise.resolve(fakeUser);
      } else {
            return Promise.reject({
                  err: 'No User found'
            });
      }
};
getUser()
      .then(res => console.log(res))
      .catch(err => console.log(err))
      .finally(() => console.log('async operation is done'))


const getUser = () => {
      return new Promise((resolve, reject) => {
            let fakeuser = {
                  name: 'Subramanian'
            };
            if (fakeuser) {
                  setTimeout(() => {
                        resolve(fakeuser)
                  }, 2000);
            } else {
                  setTimeout(() => {
                        reject({
                              err: 'User not Available'
                        })
                  }, 2000);
            }
      });
};
console.log('start....')
getUser()
      .then(res => console.log(res))
      .catch(err => console.log(err))
      .finally(() => console.log('async operation is done'))

console.log('going on')
...............................................................................

const getUser = () => {
      return new Promise((resolve, reject) => {
            let fakeuser = {
                  name: 'Subramanian'
            };
            if (fakeuser) {
                  setTimeout(() => {
                        resolve(fakeuser)
                  }, 2000);
            } else {
                  setTimeout(() => {
                        reject({
                              err: 'User not Available'
                        })
                  }, 2000);
            }
      });
};

const login = user => {
      return new Promise((resolve, reject) => {
            if (user.name === 'Subramanian') {
                  setTimeout(() => resolve({
                        loginsuccess: 'valid User'
                  }), 1000);
            } else {
                  setTimeout(() => reject({
                        err: 'Invaild User',
                        code: 400,
                  }), 1000);
            }
      });
}

const dashboard = () => {
      console.log('Welcome to Dash board');
};

console.log('start....')
getUser()
      .then(user => login(user))
      .then(() => dashboard())
      .catch(err => {
            console.log(err)
      })
      .finally(() => console.log('async operation is done'))

console.log('going on')

..................................................................................

async and await pattern:
  
 It is simplest pattern of Promises.
 It is promise driven only.

 "Sync style of Async Code" 


async key must be used with function declaration.
await is used to pause async calls

//async and await

async function sayHello() {
      //return Promise.resolve("Hello");
      return "Hello";
}
//this function returns promise :
//by default async function return promise
sayHello().then(res => console.log(res));

async function getCounter() {
      return Promise.resolve(1000);
}
getCounter().then(res => console.log(res));


............................................................................
//async and await keywords

async function startFlow() {
      //promise
      try {
            /* let fakeUser = {
                  name: 'subramanain'
            } */
            let fakeUser;
            let promise = fakeUser ? Promise.resolve(fakeUser) : Promise.reject({
                  err: 'Something went wrong'
            });
            let result = await promise; //await keyword passes the current execution in background ,once success , it result result
            console.log(result);
      } catch (err) {
            console.log(err);
      }
}
startFlow();
/////////////////////*********/////////////////////////////////////////////////////

Async Programming in IO: Non blocking IO:

1.fs io
2.network io
  -http : web apps



1.fs io

//fs.js : non block io
const fs = require('fs');

//read file
const filePath = './src/info.txt';
const config = {
      encoding: 'UTF-8'
}
console.log('start')
//readFile(path,config,handler/callback)
//readFile---stack---|libuv----->OS Kernal - starts spining a thread to read file.
fs.readFile(filePath, config, function (err, data) {
      if (err) throw err;
      console.log(data);
});
console.log('end')


//fs.js : non block io
const fs = require('fs');

//write file
const writeFilepath = './src/info-copy.txt';
const data = 'This is node IO file!';
console.log('start')
fs.writeFile(writeFilepath, data, function (err) {
      if (err) throw err;
      console.info(`The file ${writeFilepath} has been written!`)
});
console.log('end')
.....................................................................

Does node support blocking IO?

Blocking io means

  readFile----stack--frame --read file

All blocking io operations are handled by libuv thread pools.
 when you read, node will assign a thread  to read / write file.

Note:
1.Dont use blocking io apis for big files
2.Dont use blocking io apis in network applications.
3.Node supports only disk file io in blocking mode, not network apis

Blocking io dont have callbacks.


Node blocking io Operations:
.........................

fs.readFileSync()
fs.writeFileSync()


const fs = require('fs');

const filePath = './src/info.txt';
const config = {
      encoding: 'UTF-8'
}

console.log('start');
const data = fs.readFileSync(filePath, config);
console.log(data);
console.log('end')

...................................................................................
Global Objects in node:

1.process
2.JS objects-math,date....
3.exports
4.module

Global Variables:

5.__dirname
      ->Get current dir path
6.Global Objects in node:

1.process
2.JS objects-math,date....
3.exports
4.module
5.__dirname
      ->Get current dir path
6.__filename
     ->Get current dir + path__filename
     ->Get current dir + path


Use Case:
  current dir + fileName
	dir/src + fileName


//fs.js : non block io
const fs = require('fs');
const path = require('path');

/* console.log(__dirname)
console.log(__filename) */



//read file
const filePath = path.join(__dirname, 'info.txt')
const config = {
      encoding: 'UTF-8'
}
console.log('start')
fs.readFile(filePath, config, function (err, data) {
      if (err) throw err;
      console.log(data);
});
console.log('end')

...................................................................................

IO operations can be done sync or async way.

Async io operations can be done two ways.

1.Non-Streaming
2.Streaming  : Evented IO : Event driven IO.


Non Streaming IO : read / write

The operating system completes the whole file read operation, sends to node process memory  , and finally will be delivered to user

Streaming Mode: read /write


node breaks content into smaller unit called "chunk"
node streams /send data in order chunk by chunk.

Types of Streams:

1.Readaable Stream : input
2.Writeable stream : output
3.Duplex stream : read + output


Built in readable Streams:

HTTP responses, on the client
HTTP requests, on the server
fs read streams
zlib streams
crypto streams
TCP sockets
child process stdout and stderr
process.stdin

Writable Streams:
HTTP requests, on the client
HTTP responses, on the server
fs write streams
zlib streams
crypto streams
TCP sockets
child process stdin
process.stdout, process.stderr

All streaming apis are powered with events
node io streams has built in events.
events are emitted by node.
Our programs are listeners

common events in all io

data event:
 which is emitted by node, for each chunk.

close event:
The 'close' event is emitted when the stream and any of its underlying resources (a file descriptor, for example) have been closed.

end event:
The 'end' event is emitted when there is no more data to be consumed from the stream.

Event: 'error'
 The 'error' event may be emitted by a Readable implementation at any time
Typically, this may occur if the underlying stream is unable to generate data due to an underlying internal failure, or when a stream implementation attempts to push an invalid chunk of data.



const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'info.txt');
const config = {
      encoding: 'UTF-8'
}
//read stream
const inputStream = fs.createReadStream(fileName, config);

//register listeners for data,error...

let data = '';
inputStream.on('data', function (chunk) {
      console.log(`Received ${chunk.length} bytes of data.`);
      data += chunk;
});

//end event
inputStream.on('end', function () {
      console.log('There will be no more data to read!');
      console.log(data);
})

//error event: for error handling
inputStream.on('error', function (err) {
      console.log(`Some thing went wrong! ${err}`)
});

..................................................................................
const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'grains.txt');
const config = {
      encoding: 'utf8',
      flag: 'w'
};
const grains = ['wheat', 'rice', 'oats'];

const outputStream = fs.createWriteStream(fileName, config);

while (grains.length) {
      let data = grains.pop() + " ";
      outputStream.write(data);
      console.log("Wrote: %s", data);
}
///////////////////////////////////////////////////////////////////////////////////
How to create json file?

const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'config.json');
const config = {
      encoding: 'utf8',
      flag: 'w'
};
const data = [{
      name: 'IBM digital',
      version: '1.1.'
}];

const outputStream = fs.createWriteStream(fileName, config);
outputStream.write(JSON.stringify(data));
////////////////////////////////////////////////////////////////////////////////

Back Pressure:
.............

If you want to read data from one file and write into anthoer file.
If you want to read data from network sockets and write into anthoer file /another socket.

Read + Write => togther
Eg:
 copy and paste
 file moving 
 file copies

Read + write : simple eg:
//read + write
const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'info.txt');
const config = {
      encoding: 'UTF-8'
}

const outputFileName = path.join(__dirname, 'greeter.txt');
const inputStream = fs.createReadStream(fileName, config);
const outputStream = fs.createWriteStream(outputFileName, config);

//Register data event.
inputStream.on('data', function (chunk) {
      console.log(`Received ${chunk.length} bytes of data.`);
      console.log(chunk);
      outputStream.write(chunk);
});


//end event
inputStream.on('end', function () {
      console.log('There will be no more data to read!');
      outputStream.close();
})

//error event: for error handling
inputStream.on('error', function (err) {
      console.log(`Some thing went wrong! ${err}`)
});

outputStream.on('close', function () {
      console.log(`File write operation is completed`);
});

Problems when you do read and write together

1. In general read operation is faster than write operation


Back Pressure means inputstream is fast, outputstream slow, then data will be
lost.

Handling back pressure:
.......................
Pause Input stream if the Node Process memory is full(Buffer),resume if buffer/process memory is empty.

stream.pause() if stream is full
else
stream.resume() if stream is drain

const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'big.file');
const outputfileName = path.join(__dirname, 'big_copy.file');

const config = {
      encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);

readerStream.on('data', function (chunk) {
      console.log(`Received ${chunk.length} bytes of data.`);
      let buffer_good = writeStr.write(chunk);
      if (!buffer_good) readerStream.pause();
});
writeStr.on('drain', function () {
      console.log('buffer drained!');
      readerStream.resume();
});

readerStream.on('end', function () {
      //console.log(data);
});

readerStream.on('error', function (err) {
      console.log(err.stack);
});
/////////////////////////////////////////////////////////////////////////////////
const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'big.file');
const outputfileName = path.join(__dirname, 'big_copy.file');

const config = {
      encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);

//backPressure streams
//pipe method is simplest method which wraps resume,pasuse,drain 
readerStream.pipe(writeStr);
................................................................................

Web Apps in Node:
................

Tradtional web work flow

Client-----request----------------WebServer--- thread--will io operation.
Client-----request----------------WebServer----thread--will io operation.
Client-----request----------------WebServer---thread-- will io operation.
Client-----request----------------WebServer---thread-- will io operation.



Non Blocking web model(Node.js):
...............................

Client-----request------WebServer built by node---|-            will io operation.
Client-----request------WebServer built by node---|- libvu --os will io operation.
Client-----request----- WebServer built by node---|-            will io operation.
Client-----request----- WebServer built by node---|-            will io opeeration
							

What is http? 

Protocal : The rules for what?
Data transmission from one memory another memory address.


Network layer:

TCP/IP

1989 : Tim berners who created  protocal called "HTTP" 

http was created for transfering web documents from one machine machine.

http is channel, duplex channel for transfering data via internet.

How channel is represented in machine?

It is program, c program.

http itself is c program.

Program collection of variables and methods

HTTP is collections of variables and methods.

variables are called as Headers
methods are called as HTTP Verbs : GET,POST,DELETE,PUT,TRACE,DEBUG..........


HTTP is duplex stream : input and output.

input is called request from the client Persptive : read
output is called response from the server persptive. :write.

HTTP and applications:

Every pl, provides high level api to access low level http layer.

PL            java/c#/javascript(node/ajax)
|                   |
HTTP Layer        http
..............................................................................

node and http 
node provides http high level api from 'http.js' through module.


//create web server
//create web app

//start the webserver

class:http:ServerResponse : output
class:http:ClientRequest : input
class:http:Server : handling low socket operations


First web server,app:
.....................

const http = require('http');

const port = 3000;

//Request Handler /callback function called when ever new request comes to node server.
const requestHandler = function (request, response) {
      //here we handle client request and response : io
      response.write('<h1>Hello  Node Web App!</h1>');
      //close the response stream(outstream)
      response.end();
}
//Create Web Server
const server = http.createServer(requestHandler);

//start the Server / bind socket

server.listen(port, function () {
      console.group(`Node Web Server is listening @ ${port}`);
});

////////////////////////////////////////////////////////////////////////////////

How to attach events on server?

const http = require('http');

const port = 3000;

//Request Handler /callback function called when ever new request comes to node server.
const requestHandler = function (request, response) {
      //here we handle client request and response : io
      response.write('<h1>Hello  Node Web App!</h1>');
      //close the response stream(outstream)
      response.end();
}
//Create Web Server
const server = http.createServer(requestHandler);

//start the Server / bind socket

server.listen(port, function () {
      console.group(`Node Web Server is listening @ ${port}`);
});

server.on('request', function (request, response) {
      console.log(`Request received ${new Date()}`)
});
///////////////////////////////////////////////////////////////////////////////


Types of responses:

html
data : JSON.

content type: the server will send data to client in different formats that is called content type
default format is "text/plain".

which is part of "content-type" header

"content-type" : "text/plain".

content-type" : "application/json".

const http = require('http');
const USERS = require('./mock-data/users-mock');

const port = 3000;

const requestHandler = (request, response) => {
      //setting response headers
      response.setHeader('Content-Type', 'application/json');
      //request and response processing
      response.write(JSON.stringify(USERS));
      response.end() //close  stream
};
const server = http.createServer(requestHandler);


//start the server
server.listen(port, () => {
      console.log(`Server is Up at ${port}! `);
});
//////////////////////////////////////////////////////////////////////////////////

How to read data sent by client?

const http = require('http');

const port = 3000;

const requestHandler = (request, response) => {
      //setting response headers
      response.setHeader('Content-Type', 'application/json');
      //request and response processing
      let data = ''
      request.on('data', function (chunk) {
            data += chunk;
      });
      request.on('end', function () {
            console.log(data);
            response.write(JSON.stringify({
                  message: 'Data has been submitted'
            }));
            response.end() //close  stream
      });

};
const server = http.createServer(requestHandler);


//start the server
server.listen(port, () => {
      console.log(`Server is Up at ${port}! `);
});

///////////////////////////////////////////////////////////////////////////////////

IS it possible to build real time web apps by using just pure http module alone?

 Yes! but it is very complex

node modules types
1.custom module - discussed
2.in built modules - disucssed
3.third party modules - 

npm:   
 node package manager === mvn
npm is tool is used to distribute node modules to others
and you can get node modules from other others.

npm tool is distributed along with node installation

npm uses public repository server called npmjs.com npmjs.org

tools and libs,frameworks all are distributed as node modules into repository.



Javascript Project Structure:(server side/ client side)
.........................................................

The project must have two things

1.package.json file :
   meta file which describes the project information
2.node_modules folder
   which contains libs/frameworks/tools code.



create package.json file

>npm init

package.json
{
  "name": "mynode-apps",
  "version": "1.0.0",
  "description": "This is node training app",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/GreenwaysTechnology/IBM-Node-MS-Virtual.git"
  },
  "keywords": [
    "node",
    "training"
  ],
  "author": "Subramanian",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/GreenwaysTechnology/IBM-Node-MS-Virtual/issues"
  },
  "homepage": "https://github.com/GreenwaysTechnology/IBM-Node-MS-Virtual#readme"
}

npm is used

to install,uninstall,publish node modules from node repo / into node repo.

if you install third party modules , into your project, node distributes npm tool ,using this you can install,uninstall,upgrade node modules.


npm syntax:

npm commandName.


node_modules : folder which can hold all javascript modules downloaded from repo.

installing module:

>npm install  moduleName  --options
>npm i moduleName --options

options:
 --save
 --save-dev
 -g

Development

Production

if you are installing any node module, you can tell, do you want to use only for development
or development + production.

Unit testing libs : Junit.jar===>

 --save = >    development + production
 --save-dev => only for development


> npm i --save lodash


 "dependencies": {
    "lodash": "^4.17.15"
  }

index.js

const _ = require('lodash');

let array = [1];
let other = _.concat(array, 2, [3], [
      [4]
]);
console.log(other);
// => [1, 2, 3, [4]]

console.log(array);

................................................................................................

Dev Dependencies:

>npm i chai --save-dev

"devDependencies": {
    "chai": "^4.2.0"
  }


npm uninstalling:
................
>npm uninstall jquery --save


..........................................................................................

-g : global dependencies:
..........................
global package : package will be installed globally 
 inside c drive.
 looks like exe/bat files in windows

global packages not used for development(coding)

tools
 ->build system
 ->servers - webservers,testing servers
 ->compilers : babel,tsc....

Demo: 

1.tool called mocha  :  it is testing server

>npm i mocha -g


Problems with Global Modules:
..............................

g vs --save-dev:

global dependencies not good for multiple sharing projects
install tools as project specific. --save-dev

>npm i mocha --save-dev

javascript automation:
 single command trigger workflows

section is used for  automation:

"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  }

"scripts": {
    "commandName": "task to be automated"
}
commandname can be provided by npm called built in commands

eg:
start
test
postinstall
preinstall

custom commands also possible.

....................................................................................


"subu" : "node src/server.js"

For running:
>npm test | start  : in built commands
>npm run subu | npm run customCommand.

"scripts": {
    "test": "mocha",
    "subu": "node src/server.js",
    "start": "node src/server.js",
    "build": "webpack"
  }

...............................................................................................

ES 6 modules:
  next module system after commonjs(exports,module.exports,require)

ES 6 moudles are javascript committe modules

export = exports =>code will be packed inside object
export default = module.exports =  code will be returned as it is
import == require()

Note: Node does not support es 6 modules, only cjs

How to run the es 6 module on node?

webpack : web pack is npm module, / tool is used to bundle js apps  which are portable on browser/node , without worrying about module patterns.

>npm i webpack webpack-cli  --save-dev

webpack.config.js
const path = require('path');

module.exports = {
      entry: './src/index.js',
      output: {
            path: path.resolve(__dirname, 'dist'),
            filename: 'bundle.js'
      }
};

  "scripts": {
    "test": "mocha",
    "subu": "node src/index.js",
    "build": "webpack"
  }

>npm run build


Webpack is awesome tool for distributing application to production

............................................................................................

Web applications on node:

Problems with http core module.

1.complex apps you cant write
2.no design patterns
3.url mappings,method mappings


Frameworks:

 1.express.js : it is web framework written by node core team


Express is Node framework built on the top of node http module.


You can create two types of application

1.RESTFull web services
2.Dynamic web application 


HOW To implement REST Architecutre?

Every pl today provides implementation for build rest full architecutres.

eg:
java
->JXRS
Spring Rest

c#
web api

javascript - node ->express


...........................................................................................

Express app:


Setup:

>mkdir myexpress-app
>cd myexpress-app
>code .
>npm init

>npm i  express --save

Express and REST architecture:
..............................

Express core concepts:

1.Express Application : collection of many objects
2.Express Modules
3.Express middlewares
4.Express with third party libs.


Use case : How to create simple REST API : get,post,delete,put...


const express = require('express');

const port = 3000;
//Create Application Object
const app = express();

//REST End Points
//http://localhost:3000/api/list

app.get('/api/list', function (req, res) {
      res.end('api list get is called');
})

app.post('/api/list', function (req, res) {
      res.end('api list post is called');
})

app.put('/api/list', function (req, res) {
      res.end('api list put is called');
})
app.delete('/api/list', function (req, res) {
      res.end('api list delete is called');
})


//start server 
app.listen(port, function () {
      console.log(`Express Server is Ready at ${port}`);
});

//////////////////////////////////////////////////////////////////////////////////////////////

Modularity : 

The below is not modular

const express = require('express');
const TODOS = require('./mock-data/todos');
const USERS = require('./mock-data/users');

const port = 3000;
//Create Application Object
const app = express();

//REST End Points :TODOS

//http://localhost:3000/api/todos/list

app.get('/api/todos/list', function (req, res) {
      res.json(TODOS);
})
//http://localhost:3000/api/todos/:id
//http://localhost:3000/api/todos/2
app.get('/api/todos/:id', function (req, res) {
      //read Request parameter
      const id = parseInt(req.params.id)
      const filteredTo = TODOS.filter(todo => {
            return todo.id === id;
      });
      res.json(filteredTo);
})
//REST END POINT : USERS

//http://localhost:3000/api/users/list

app.get('/api/users/list', function (req, res) {
      res.json(USERS);
})
//http://localhost:3000/api/users/:id
//http://localhost:3000/api/users/2
app.get('/api/users/:id', function (req, res) {
      //read Request parameter
      const id = parseInt(req.params.id)
      const filteredUsers = USERS.filter(user => {
            return user.id === id;
      });
      res.json(filteredUsers);
})

//start server 
app.listen(port, function () {
      console.log(`Express Server is Ready at ${port}`);
});

Modularity : Express apps provides logical modularity , separating application into logical modules based on "domain" domain driven design.

Todo module
User module
Post module
Customer module
invoice module

Express provides a spcial Object called "Router" Object which helps to separate code into modular way.


src/todos/todosModule.js

//build todos rest end points
const express = require('express');
const TODOS = require('../mock-data/todos');

//create router : submodule
const todosModule = express.Router();

//REST End Points :TODOS
//http://localhost:3000/api/todos/list
todosModule.get('/list', function (req, res) {
      res.json(TODOS);
})

//http://localhost:3000/api/todos/:id
//http://localhost:3000/api/todos/2
todosModule.get('/:id', function (req, res) {
      //read Request parameter
      const id = parseInt(req.params.id)
      const filteredTo = TODOS.filter(todo => {
            return todo.id === id;
      });
      res.json(filteredTo);
})

module.exports = todosModule;

//build todos rest end points
const express = require('express');
const USERS = require('../mock-data/users');

//create router : submodule
const usersModule = express.Router();




src/todos/usersModule.js
//REST END POINT : USERS

//http://localhost:3000/api/users/list

usersModule.get('/list', function (req, res) {
      res.json(USERS);
})
//http://localhost:3000/api/users/:id
//http://localhost:3000/api/users/2
usersModule.get('/:id', function (req, res) {
      //read Request parameter
      const id = parseInt(req.params.id)
      const filteredUsers = USERS.filter(user => {
            return user.id === id;
      });
      res.json(filteredUsers);
})

module.exports = usersModule;


src/app.js
const express = require('express');
const todosModule = require('./todos/todosmodule');
const usersModule = require('./users/usersmodule');

const port = 3000;
//Create Application Object
const app = express();
//Request will be passed to app
//configure submodules with app
app.use('/api/todos', todosModule);
app.use('/api/users', usersModule);


//start server 
app.listen(port, function () {
      console.log(`Express Server is Ready at ${port}`);
});


///////////////////////////////////////////////////////////////////////////////
sending data to Express app!
............................

todosModule.post('/', function (req, res) {

      let todo = ''
      req.on('data', function (chunk) {
            todo += chunk;
      });
      req.on('end', function (chunk) {
            res.json({
                  message: todo
            })
      });


});

In express , you need not attach events to read data.

req.body


Express app architecture:

express has two things
1.URL mapping and request processing : app.get('url')
2.Routers , to create moduels

middlewares:
...........

what is middleware?

 it is utility can be plugged in express application.

Express provides only
1.request and response processing.
2.Routers :in to modules.

Rest of application features

1.loggers
2.security
3.database connectivity
3.data formating
4.view engine integration
 middlewares

Types of middlewares
1.custom middlewares
2.third party middlewares


middleware workflows:

client----request---node--server---express application---

			   | ---m1
			   | --m2
	express application| ---m3   ----Request Processing(get,post...)
			   |---m4
			   | --mn


How to attach middleware with application object?

app.use(middleware) : middleware registeration at app level : global middlewares
router.use(middleware) : middleware registeration at module level



Types of middlewares based on Use:
.................................
Application-level middleware
  middleware attached at application : global middlewares
Router-level middleware
 middleware attached at router level(module) : module specific
Error-handling middleware
 for handling global errors
Built-in middleware
 provided by express itself
Third-party middleware
 provided by others.

Built-in middleware
 provided by express itself

1.body-parser :
  which parses client input data into javascript object


>npm install body-parser --save

How to attach body-parser middleware at application object level?

const bodyParser = require('body-parser');



////////////////////////////////////////////////////////////////////////////
//Global/application  Middleware configuration

// parse application/json
app.use(bodyParser.json())

// parse application/x-www-form-urlencoded
app.use(bodyParser.urlencoded({
      extended: false
}))


////////////////////////////////////////////////////////////////////////////

const express = require('express');
const todosModule = require('./todos/todosmodule');
const usersModule = require('./users/usersmodule');
const bodyParser = require('body-parser');

const port = 3000;
//Create Application Object
const app = express();

// parse application/json
app.use(bodyParser.json())

// parse application/x-www-form-urlencoded
app.use(bodyParser.urlencoded({
      extended: false
}))


//Request will be passed to app
//configure submodules with app
app.use('/api/todos', todosModule);
app.use('/api/users', usersModule);


//start server 
app.listen(port, function () {
      console.log(`Express Server is Ready at ${port}`);
});

app.on('request', function (req, res) {
      console.log(`Server is listening ${req.url}`)
});

//build todos rest end points
const express = require('express');
const TODOS = require('../mock-data/todos');

//create router : submodule
const todosModule = express.Router();

//REST End Points :TODOS
//http://localhost:3000/api/todos/list
todosModule.get('/list', function (req, res) {
      res.json(TODOS);
})

//http://localhost:3000/api/todos/:id
//http://localhost:3000/api/todos/2
todosModule.get('/:id', function (req, res) {
      //read Request parameter
      const id = parseInt(req.params.id)
      const filteredTo = TODOS.filter(todo => {
            return todo.id === id;
      });
      res.json(filteredTo);
})
todosModule.post('/', function (req, res) {
      let todo = req.body;
      console.log(todo);
      res.json(TODOS.concat(todo));
});


module.exports = todosModule;


How to write custom middlewares?

1.It is function only , express request processing function

middleware can be written for any url pattern and any http method in the application.

general middleware syntax;

 app.use(function(req,res,next){});


middleware chian :

  m1--next-->m2--next--m3-next--mn---next---requestProcessing

..................................................................................

//build todos rest end points
const express = require('express');
const TODOS = require('../mock-data/todos');

//create router : submodule
const todosModule = express.Router();

//middleware is called for any url,any method in the TODOS Module
todosModule.use(function (req, req, next) {
      console.info('TODOS API started')
      next();
})
todosModule.use('/list', function (req, res, next) {
      console.info(`TODOS  API : ${req.method} `)
      next();
})

//REST End Points :TODOS
//http://localhost:3000/api/todos/list
todosModule.get('/list', function (req, res) {
      res.json(TODOS);
})

//http://localhost:3000/api/todos/:id
//http://localhost:3000/api/todos/2
todosModule.get('/:id', function (req, res) {
      //read Request parameter
      const id = parseInt(req.params.id)
      const filteredTo = TODOS.filter(todo => {
            return todo.id === id;
      });
      res.json(filteredTo);
})
todosModule.post('/', function (req, res) {
      let todo = req.body;
      console.log(todo);
      res.json(TODOS.concat(todo));
});


module.exports = todosModule;
..................................................................................


const express = require('express');
const todosModule = require('./todos/todosmodule');
const usersModule = require('./users/usersmodule');
const bodyParser = require('body-parser');

const port = 3000;
//Create Application Object
const app = express();

//middleware : custom
//middleware syntax similar to request handler but it takes extra parameter
// next
//global middlewares , middle for any url,any method
app.use(function (req, res, next) {
      //middleware logic
      console.info('IBM digital api platform started...');
      next();
});

app.use(function (req, res, next) {
      //middleware logic
      console.info('This Platform is used to automate digital apis...');
      next();
});
// parse application/json
app.use(bodyParser.json())

// parse application/x-www-form-urlencoded
app.use(bodyParser.urlencoded({
      extended: false
}))


//Request will be passed to app
//configure submodules with app
app.use('/api/todos', todosModule);
app.use('/api/users', usersModule);


//home page
app.get('/', function (req, res) {
      res.end('<h1>IBM digitial api platform </h1>');
});


//start server 
app.listen(port, function () {
      console.log(`Express Server is Ready at ${port}`);
});

app.on('request', function (req, res) {
      console.log(`Server is listening ${req.url}`)
});

..................................................................................

Express middlewares  are project or lib specific.

Eg:
if i want to connect mongodb as back end.

i need middleware.

 Express --->mongooseMiddleware---->Mongodb

Loggers
Auth : oauth 
sql -oracle,mssql 
...............................................................................


Microservices on Node.js:
........................

What is Microservices?

Microservice is  yet another Architecture for building distributed Applications.


Distributed Computing : Overview

Any architecture:
1.Data
2.How to process data - biz logic
3.How to view data / How to send data  - Presentation

1.Main frame based architecture

Main frame acts as central machine which stores and process the data.

Dump teriminals are connected with Mainframes : client

Advantages:
1.Centeralized management
2.High secure system.

Drabacks:
1.High Cost
2.Scallablity is difficult
3.Perfomance may be bad when more requests comes


Client -Server Architectures:

1-tier client-server
 ->Server is Personal Computers ,having data and biz logic + Presentation : Local networks

2-tier client-server

 ->Server is Personal Computers ,having data and biz logic + Presentation : wide    area,MAN,internet networks

 ->Client  is Personal computer having presentation logic ,where server has data + biz logic

3-tier client-server
   data is one server ->Db server
   biz logic is kept is one server ->App server
   client is kept is separte  machine -  Client
 
N-tier Client-Server

   Client -----Web Server ----- AppServer(biz logic) ----Messaging Servers---Database Servers---Mail Servers --Directory Servers
 
 works on internet infrastructure.


Pros and cons of N-tier client-server architecture

Props:
1. separation of application across multiple machines: loosly coupled system.

Cons:

1.Vendor lock in 
 if you select application on java... every thing should be towards java

 Monolothic Application: one application,one tech stack
  Single tech stack.
 Polyglot : database,language is not possible.

................................................................................

Software deliver model

Legacy model:

Java :

Dev
    Build application

 pack the application as unit "jar /war /ear"

Testing
  move applicaiton on testing env
Test the applications.
  if success
	move the application into production

Production
  War----Deploy on Machines
Deployment problems  
 -os com
 -server com issues
 -dependencies issues

Live: => Maintaince
..............................................................................

Agile:

Microservices is distributed application dev,testing,deploying application based on agile process.

Dev ops : Software process which enables application dev,test,dep in automation
 which says one slogan called "C" "Continues"


     (BDD)
Continues Requirement--->Continous Dev---Continuous Testing-- Continuous--Deployment--Live

Tools:
 Dev ops
   -CI /CD /CT - integration of all work flows
	dev ----SCM(git/svn)-----jenkins----testing pipelines---Deployments(containers -dockers).

 req-Dev--Test--Delivery--Live
................................................................................

Microservice is all about collection of Patterns

1.Dev Patterns
2.Testing Patterns
3.Deployment Patterns

...............................................................................

What is Service?
  
 Service is a single Program like class OrderService
 Service is a single module in the application "OrderModule"


Microservice Principls

1.Domain driven Design
  Application must be broken into smaller units called modules
eg: ECOMMERCE

                ECommerce Manager
		    |	
		  Devops
		  Testing
		  Dev

-Order - orderTeam
  Dev,Test,Dev ops
 Every team must have their own mangers,leads,dev,arch,operatios(dev ops enginer)

-Customer -Customer Team
  Dev,Test,Dev ops
 Every team must have their own mangers,leads,dev,arch,operatios(dev ops enginer)

-Inventory -Inventory
  Dev,Test,Dev ops
 Every team must have their own mangers,leads,dev,arch,operatios(dev ops enginer)


2.Resilience : Falut Tolerance

eg :
  order application has gone for live , which are running on 3 servers
  if one server goes down, we have to instantlly up new server for failed ones.

 
3.Observerablity: Monitoring
  
 How many services are up and runnign
 How many services failed
 How to log each services activties
 How to enable disbuted transactions
 How to watch live traffic. 
 


4.Automation : Devops enginering

  Req--BDD
  CI /CD integration
  automation in testing
  using modern devops tools

.............................................................................

How to implement Microservices

Microservice is just architecture.

Microservices is poly glot : language/database/tech independent.



How to implement microservices:

1.ON JVM , we have so many ms implementations

 Spring framework
  ->Spring-Cloud : framework for building ms distributed application.
 
 Ecplise Vertx framework
   - written jvm


2.ON Node, we have so many ms implementations
 
  Moleculer js : MS implementation on node js

..................................................................................

Project setup:

We can do in two ways

1.create folders add moleculer dependencies
2.You can use moleculer-cli tool 


1.create folders add moleculer dependencies

>mkdir ibmnode-ms
>cd ibmnode-ms
>npm init
>npm i  moleculer --save

What is moleculer?

 moleculer is a framework, built on top express.js , coimbing many middlewares.


Why moleculer / Moleculer features:


1.Promise-based solution (async/await compatible)

2.request-reply concept

3.support streams

4.support event-driven architecture with load balancing

5.built-in service registry & dynamic service discovery

6.load balanced requests & events (round-robin, random, cpu-usage, latency)


7.many fault tolerance features (Circuit Breaker, Bulkhead, Retry, Timeout, Fallback)

8.supports middlewares

9.supports versioned services

10.service mixins

11.built-in caching solution (memory, Redis)

12.pluggable transporters (TCP, NATS, MQTT, Redis, NATS Streaming, Kafka)


13.pluggable serializers (JSON, Avro, MsgPack, Protocol Buffers, Thrift)


14.pluggable validator

15.multiple services on a node/server

16.all nodes are equal, no master/leader node

17.parameter validation with fastest-validator

18.built-in health monitoring & metrics

19.official API gateway module and many other modules…

...............................................................................

Moleculer Componets(Objects):

Service Implementation:
 Service is Object which expose your biz functionality.

Components of moleculer:

1.ServiceBroker === node process : instance of node runtime.
	It is heart of Moleculer framework
  Which represents an Node /Process
 ServiceBroker contains list of services

2.Service
  Serivice represents object which exposes biz functionality.

Steps For creating single Node and service:

1.create ServiceBroker Object.
2.Create Service
3.Start ServiceBroker
4.You can invoke Service.


1.create ServiceBroker Object.

const broker = new ServiceBroker();

2.Create Service
broker.createService({configuration})

 configuration is literal object , which is called service configuration.

//create service on Broker
broker.createService({
      name: 'GreeterService',
      //biz logic
      actions: {
            //ms biz api
            hello() {
                  return 'Hello Moleculer!';
            }
      }
})

3.Start ServiceBroker  

  broker.start()

Note: you need to install

 >npm install moleculer-repl


>invoke Service
In Repl terminal
$call GreeterService.hello


const {
      ServiceBroker
} = require('moleculer');

//Create Service Broker Object :Node(Process)
const broker = new ServiceBroker();

//create service on Broker
broker.createService({
      name: 'GreeterService',
      //biz logic
      actions: {
            //ms biz api
            hello() {
                  return 'Hello Moleculer!';
            }
      }
})
//start process
broker.start();
broker.repl();










